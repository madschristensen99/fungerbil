// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// generated by snarkjs extract + manual cleanup
contract Groth16Verifier {
    uint256 constant q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
    uint256 constant a = 0x04c9a3cd4e8a291435442493d5cd2cea5ca65b41d0692758b8f7e6deb5b28a9b;
    uint256 constant b = 0x1040d270077b5ff0b190464d4e71f003a8b5740a1197964f37d7ea7f71e5d8c6;
    uint256 constant gamma = 0x121f7f5af0a1dce0769d65b38dfd40415b35b334615364dcd42d569c1f5d6cf8;
    uint256 constant delta = 0x22b3c9194e9834a3d2eb6287cc2692edce01d8ad14304740a8bce8d926063e46;
    uint256 constant gamma_abc_len = 5;
    
    uint256[gamma_abc_len][2] public IC;

    constructor() {
        IC[0][0] = 0x2a2c12c5f1c8babdd447b1a237222b5c03df7f2a1f36c7d6f05695b3f721539e;
        IC[0][1] = 0x0c7cdf38f5777ee5bf00a405c34f0b8926512fd67bb4bd30423b0c02980921bd;
        IC[1][0] = 0x06543a6a600abb7ca59e90e3bd2a844c6fd7c2e8c7bb43a441aba8df0af2178a;
        IC[1][1] = 0x1e460e44f0e40a3b0ae925c02c4c7253444e01cfa2c250b5e792c916868b0677;
        IC[2][0] = 0x26f7d1ec1ac7a8f440c349c44f29703d54fc82e5293199e8eb6210a3b9aa97e;
        IC[2][1] = 0x26dfdd585084ca8b0c33444124d8e586494125a5f0573bbca5718991c2bb426;
        IC[3][0] = 0x2bbb45b3c8e183e03b34dd56d1d25405104e92f28d4e8fcbb9641d672c649c78;
        IC[3][1] = 0x119929d50f23889be2ba32fad264404c2ac34428fe2e5bc23d15f1e1831fa08d;
        IC[4][0] = 0x2ad3693052c9eecfba8cb7f38fe87feb489ce55cf3fa7c2c7b760cf9d9abc99;
        IC[4][1] = 0x0a221d9e2795cdc5960e5f3030a70d49912b5f30e142aa03ec54493ab1e79ad;
    }

    function verifyingKey() public pure returns (uint256[2] memory a1, uint256[2] memory a2, uint256[2] memory beta, uint256[2] memory gamma, uint256[2] memory delta, uint256[gamma_abc_len][2] memory ic) {
        return (a, b, gamma, delta, IC);
    }

    function ic(uint256 i) public view returns (uint256[2] memory) {
        if (i >= gamma_abc_len) revert("invalid IC index");
        return IC[i];
    }

    function mulmod(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {
        uint256 res;
        assembly {
            res := mulmod(a, b, c)
        }
        return res;
    }

    function addmod(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {
        uint256 res;
        assembly {
            res := addmod(a, b, c)
        }
        return res;
    }

    function expand(uint256[2] memory e) internal pure returns (uint256[3] memory) {
        assembly {
            mstore(add(e, 0x40), q)
        }
        return [e[0], e[1], q];
    }

    function pairing(uint256[12] memory input) internal view returns (bool) {
        uint256[1] memory out;
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 8, input, 384, out, 0x20)
        }
        require(success, "pairing op failed");
        return out[0] != 0;
    }

    function negate(uint256 p) internal pure returns (uint256) {
        return q - (p % q);
    }

    function verifyProof(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[4] memory input) public view returns (bool) {
        uint256[3] memory mul_input;
        uint256[3] memory add_input;
        uint256[3] memory input_gen;
        uint256[1] memory out;

        mul_input[0] = IC[0][0];
        mul_input[1] = IC[0][1];
        mul_input[2] = input[0];

        uint256[3] memory input_accumulator;
        input_accumulator[0] = mul_input[0];
        input_accumulator[1] = mul_input[1];
        input_accumulator[2] = mul_input[2];

        for (uint i = 1; i < 4; i++) {
            input_gen[0] = IC[i][0];
            input_gen[1] = IC[i][1];
            input_gen[2] = input[i];

            input_accumulator[0] = addmod(mulmod(input_accumulator[0], input_gen[2], q), mulmod(input_gen[0], input_accumulator[2], q), q);
            input_accumulator[1] = addmod(mulmod(input_accumulator[1], input_gen[2], q), mulmod(input_gen[1], input_accumulator[2], q), q);
            input_accumulator[2] = mulmod(input_accumulator[2], input_gen[2], q);
        }

        mul_input[0] = IC[4][0];
        mul_input[1] = IC[4][1];
        mul_input[2] = 1;

        add_input[0] = addmod(input_accumulator[0], mul_input[0], q);
        add_input[1] = addmod(input_accumulator[1], mul_input[1], q);

        return pairing([
            add_input[0], add_input[1],
            19167053507389192669651933549750039898597240015333450567280898934927808893749,
            17561850299615221362116217187685095281301297088217344914543092322096435149237,
            b[0][1], b[0][0], b[1][1], b[1][0],
            negate(a[0]), a[1],
            0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,
            0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,
            gamma, negate(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),
            add_input[0], add_input[1],
            0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,
            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0,
            delta, negate(0x22b3c9194e9834a3d2eb6287cc2692edce01d8ad14304740a8bce8d926063e46),
            c[0], negate(c[1])
        ]);
    }
}

contract MoneroPaymentVerifier is Groth16Verifier {
    mapping(bytes32 => bool) public proofUsed;
    
    event ProofVerified(bytes32 indexed proofHash, address indexed recipient, uint256 amount);

    function verifyPayment(
        uint256[2] calldata pA,
        uint256[2][2] calldata pB,
        uint256[2] calldata pC,
        uint256[4] calldata pub   // [destHash, amount, txHashHash, blockHashHash]
    ) external returns (bool) {
        bytes32 key = keccak256(abi.encodePacked(pub));
        require(!proofUsed[key], "Proof already used");
        
        bool ok = verifyProof(pA, pB, pC, pub);
        require(ok, "Invalid proof");
        
        proofUsed[key] = true;
        emit ProofVerified(key, msg.sender, pub[1]);
        
        return true;
    }
}