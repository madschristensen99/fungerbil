const { ethers } = require("hardhat");

/**
 * Real Monero transaction data for testing
 * These are actual transactions from stagenet and mainnet
 */

const realTransactions = [
    {
        name: "TX1 - Stagenet 20 XMR",
        hash: "5caae835b751a5ab243b455ad05c489cb9a06d8444ab2e8d3a9d8ef905c1439a",
        block: 1934116,
        secretKey: "4cbf8f2cfb622ee126f08df053e99b96aa2e8c1cfd575d2a651f3343b465800a",
        amount: 20000000000, // 0.02 XMR = 20 billion piconero
        destination: "53Kajgo3GhV1ddabJZqdmESkXXoz2xD2gUCVc5L2YKjq8Qhx6UXoqFChhF9n2Th9NLTz77258PMdc3G5qxVd487pFZzzVNG",
        output_index: 0,
        node: "https://stagenet.xmr.ditatompel.com"
    },
    {
        name: "TX2 - Stagenet 10 XMR",
        hash: "efab02571fe41662cd1d10b551e9cd822bf2a32b4b5d23f653862a98b0af2682",
        block: 1948001,
        secretKey: "c7637fdfa0ae785a8982473b49a6c1ebf082e6737b837f4e1c40a270acf8130e",
        amount: 10000000000, // 0.01 XMR = 10 billion piconero
        destination: "74Di3cYaTj7DG5D7ucHEeiSZzrH9kyrFX8ujg2S3ydoZQEkKhpFjGkGLcpenYEHMW1aYNQcy6n75MbDfFwch4657E8WjVhE",
        output_index: 0,
        node: "https://stagenet.xmr.ditatompel.com"
    },
    {
        name: "TX3 - Stagenet 1.15 XMR",
        hash: "827368baa751b395728f79608c0792419a88f08119601669baede39ba0225d4b",
        block: 2023616,
        secretKey: "ab923eb60a5de7ff9e40be288ae55ccaea5a6ee175180eabe7774a2951d59701",
        amount: 1150000000, // 0.00115 XMR = 1.15 billion piconero
        destination: "77tyMuyZhpUNuqKfNTHL3J9AxDVX6MKRvgjLEMPra23CMUGX1UZEHJYLtG54ziVsUqdDLbtLrpMCnbPgvqAAzJrRM3jevta",
        output_index: 0,
        node: "https://stagenet.xmr.ditatompel.com"
    },
    {
        name: "TX4 - Mainnet 931 XMR",
        hash: "bb1eab8e0de071a272e522ad912d143aa531e0016d51e0aec800be39511dd141",
        block: 3569096,
        secretKey: "9be32769af6e99d0fef1dcddbef68f254004e2eb06e8f712c01a63d235a5410c",
        amount: 931064529072, // 931.064529072 XMR in piconero
        destination: "87DZ8wkCoePVH7UH7zL3FhR2CjadnC83pBMqXZizg7T2dJod5rzQuAMbBg5PtcA9dHTtWAvrL7ZCTXEC2RDV3Mr4HJYP9gj",
        output_index: 0,
        node: "https://monero-rpc.cheems.de.box.skhron.com.ua:18089"
    }
];

/**
 * Convert real Monero transaction to test proof data
 * In production, this would come from actual PLONK proof generation
 * For now, we use mock proofs with real transaction amounts
 */
function getRealTransactionProof(txIndex) {
    const tx = realTransactions[txIndex];
    if (!tx) {
        throw new Error(`Transaction ${txIndex} not found`);
    }
    
    // Mock proof (in production, this would be generated by snarkjs)
    const proof = new Array(24).fill(1);
    
    // Mock Ed25519 proof using Ed25519 base point G (valid curve point)
    // G = (15112221349535400772501151409588531511454012693041857206046113283949847762202,
    //      46316835694926478169428394003475163141307993866256225615783033603165251855960)
    const G_x = "15112221349535400772501151409588531511454012693041857206046113283949847762202";
    const G_y = "46316835694926478169428394003475163141307993866256225615783033603165251855960";
    
    const ed25519Proof = {
        R_x: ethers.zeroPadValue(ethers.toBeHex(G_x), 32),  // Use G as R (valid point)
        R_y: ethers.zeroPadValue(ethers.toBeHex(G_y), 32),
        S_x: ethers.zeroPadValue(ethers.toBeHex(G_x), 32),  // Use G as S (valid point)
        S_y: ethers.zeroPadValue(ethers.toBeHex(G_y), 32),
        P_x: ethers.zeroPadValue(ethers.toBeHex(G_x), 32),  // P = G
        P_y: ethers.zeroPadValue(ethers.toBeHex(G_y), 32),
        B_x: ethers.zeroPadValue(ethers.toBeHex(G_x), 32),  // B = G
        B_y: ethers.zeroPadValue(ethers.toBeHex(G_y), 32),
        H_s: ethers.zeroPadValue(ethers.toBeHex("0"), 32),  // H_s = 0, so P = 0·G + B = B = G ✓
        A: ethers.keccak256(ethers.toUtf8Bytes(`A_${tx.hash}`))
    };
    
    // Public signals must match Ed25519 proof (Security Fix #1: Proof Binding)
    const publicSignals = new Array(70).fill(0);
    publicSignals[0] = tx.amount; // Real amount in piconero
    publicSignals[1] = BigInt(ed25519Proof.R_x); // R_x from Ed25519 proof
    publicSignals[2] = BigInt(ed25519Proof.R_y); // R_y from Ed25519 proof
    publicSignals[3] = BigInt(ed25519Proof.S_x); // S_x from Ed25519 proof
    publicSignals[4] = BigInt(ed25519Proof.S_y); // S_y from Ed25519 proof
    publicSignals[5] = BigInt(ed25519Proof.P_x); // P_x from Ed25519 proof
    publicSignals[6] = BigInt(ed25519Proof.P_y); // P_y from Ed25519 proof
    
    // Mock DLEQ proof
    const dleqProof = {
        c: ethers.keccak256(ethers.toUtf8Bytes(`c_${tx.hash}`)),
        s: ethers.keccak256(ethers.toUtf8Bytes(`s_${tx.hash}`)),
        K1: ethers.keccak256(ethers.toUtf8Bytes(`K1_${tx.hash}`)),
        K2: ethers.keccak256(ethers.toUtf8Bytes(`K2_${tx.hash}`))
    };
    

    
    // Use real transaction hash
    const txHash = ethers.keccak256(ethers.toUtf8Bytes(tx.hash));
    
    return {
        tx,
        proof,
        publicSignals,
        dleqProof,
        ed25519Proof,
        txHash
    };
}

/**
 * Calculate required collateral for a transaction
 * @param {number} piconeroAmount - Amount in piconero
 * @param {BigInt} xmrPriceDAI - XMR price in DAI (18 decimals)
 * @param {number} collateralRatio - Collateral ratio (e.g., 150 for 150%)
 * @returns {BigInt} Required collateral in DAI (18 decimals)
 */
function calculateRequiredCollateral(piconeroAmount, xmrPriceDAI, collateralRatio = 150) {
    // Convert piconero to XMR (18 decimals)
    const PICONERO_PER_XMR = ethers.parseUnits("1", 12);
    const xmrAmount = (BigInt(piconeroAmount) * ethers.parseEther("1")) / PICONERO_PER_XMR;
    
    // Calculate DAI value
    const daiValue = (xmrAmount * xmrPriceDAI) / ethers.parseEther("1");
    
    // Apply collateral ratio
    const requiredCollateral = (daiValue * BigInt(collateralRatio)) / 100n;
    
    return requiredCollateral;
}

module.exports = {
    realTransactions,
    getRealTransactionProof,
    calculateRequiredCollateral
};
